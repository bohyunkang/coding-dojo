## 모의고사

정답 배열 answers를 입력받으면 가장 많은 문제를 맞힌 사람이 누구인지 찾는 문제. ex. `[1, 2, 3, 4, 5] => [1]`

### 1. 이해

- 수포자 1, 2, 3이 찍는 패턴을 어떻게 반복시켜야 하나?
  -> 패턴이 만약 answers보다 길면 상관이 없지만, 패턴의 길이가 더 짧은 경우 answers의 길이만큼 패턴의 길이도 늘어나야 한다.
  -> 그냥 패턴의 길이를 answers 길이만큼 만들자. ex) `answers: [1, 2, 4, 3, 5, 2, 3]` || `pattern: [1, 2, 3, 4, 5, 1, 2]`
- 그렇게 두 배열을 비교해서 가장 많은 문제를 맞힌 사람을 찾는다.
  -> 이때 만약 동점이라면 해당 수포자 번호를 오름차순으로 정렬한다.

### 2. 계획

- 수포자 1, 2, 3의 패턴을 answers 길이에 맞게 반복하는 함수를 만든다.
- 수포자의 답안 배열과 정답 배열을 비교해서 많이 맞힌 수포자를 찾는 함수를 만든다.
  -> 이때 많이 맞힌 수포자가 한 명 이상이라면 오름차순 정렬한다.

### 3. 실행

-

### 4. 반성

- 문제풀이 시간이 오래 걸린다.
- 문제를 잘게 쪼개는 것도 좋지만 map을 한번 돌린 값에 중간 메서드를 추가해서 한번에 원하는 값을 구할 수 있는 방법으로도 구현해보자!
