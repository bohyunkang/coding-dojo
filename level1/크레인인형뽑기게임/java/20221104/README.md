## [크레인 인형뽑기 게임](https://school.programmers.co.kr/learn/courses/30/lessons/64061?language=java)
게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성하는 문제

### 1. 이해
![image](https://user-images.githubusercontent.com/65386533/199860708-a6e4b6c1-1703-41f9-b5a2-79b58ba2dcdb.png)
- 위 사진과 같이 제공받은 2차원 배열 board(왼쪽)를 moves의 순서에 맞춰 열마다 뽑아온다.
- 그렇게 뽑아온 숫자중에 똑같은 숫자가 나란히 있는 경우 해당 숫자들은 제거된다.
- 최종적으로 제거된 숫자들의 갯수가 정답이 된다.

### 2. 계획
- 뽑은 인형을 담을 Stack을 준비하고 기본적으로 0을 세팅해놓는다.
- moves의 길이만큼 순회하면서 board의 길이만큼 다시 순회한다.
- 만약 board[j][move - 1]이 0이라면 인형이 없는 것이기 때문에 무시한다.
- 0이 아니라면 Stack(바구니)의 가장 윗 요소와 board[j][move - 1]가 같은지 비교한다.
- 같다면 인형이 터지는 것이기 때문에 Stack에 pop을 하고 answer에 2를 더한다.
- 다르다면 Stack에 board[j][move - 1]를 push한다.
- answer를 리턴한다.

### 3. 실행
- 

### 4. 회고
- if 문 조건이 잘못되어 계속 result가 이상한 값을 반환해서 시간이 많이 걸렸다. stream으로 푸는 것도 아닌데 이렇게 시간이 오래 걸리면 어떡하나.. 아무래도 테스트 케이스를 잘게 쪼개지 않고 작업을 해서 생긴 문제인 거 같다. 시간 제한이라는 요소 때문에 계속 테스트 케이스를 열심히 짜지 않게 되는데, 그때문에 더 오래 걸리는 거 같다ㄱ- 테스트 케이스를 잘게 쪼개보자!!
- stream을 활용해서 풀어야 한다는 강박이 있었는데, 그러다보니 처음에 계획을 세울 때 많은 시간이 걸리는 거 같다. 그런데 내가 코테를 준비하는 이유는 궁극적으로 코테를 통과해서 다음 면접 단계로 넘어가기 위함이지 않나? 오히려 Java에서는 for문을 써서 푸는 것이 더 효과적일 때가 많은 거 같으니 우선은 for문으로 완성하고, 리팩터링 개념으로 stream을 사용해보자! (게다가 for문이 대부분의 경우에서는 stream보다 시간도 더 적게 든다!)   
